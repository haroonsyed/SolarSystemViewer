#version 430 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

const unsigned int bodiesPerCell = 1;

struct Body {
	vec4 position;
	vec4 velocity;
	float mass;
	uint align1;
	int align2;
	int align3;
};

struct TreeCell {
	Body bodies[bodiesPerCell];
	vec4 COM;
	int lock;
	int numberOfBodies;
	float mass;
};

layout(std430, binding = 4) buffer bodiesBuffer {

  Body bodies[];

};

readonly layout(std430, binding = 5) buffer treeBuffer {

  TreeCell tree[];

};

uniform uint treeSize;
uniform uint bodySize;
uniform float deltaT;
uniform float G;

void main() {

	const uint gid = gl_GlobalInvocationID.x;

	if(gid >= bodySize) {
		return;
	}

	const vec2 bodyPosition = bodies[gid].position.xy;
	const vec2 bodyVelocity = bodies[gid].velocity.xy;
	const float m1 = bodies[gid].mass;
	
	uint stack[60];
	uint levelStack[60];
	stack[0] = 0;
	levelStack[0] = 0;
	int stackPosition = 0;

	const float theta = 0.0;
	vec2 force = vec2(0.0);

	// Traverse tree and sum force according to F = Gm1m2/r2
	while(stackPosition >= 0) {

		// pop off the stack
		const uint cellIndex = stack[stackPosition];
		const uint childIndex = cellIndex * 4 + 1;
		const uint level = levelStack[stackPosition];
		const vec2 secondBodyPosition = tree[cellIndex].COM.xy;

		const vec2 r = secondBodyPosition - bodyPosition;
		const float r2 = dot(r, r);

		if( r2 > 1e-6 ) {
		
			const float thisTheta = (2e2/pow(2, level))  / sqrt(r2);
	
			// add force if theta is small enough (ignore multi cell for now)
			if(thisTheta < theta || tree[cellIndex].lock == -1) {
				const float forceMag = (G * m1 * tree[cellIndex].mass) / r2;
				force += forceMag * normalize(r);
			}
			// add the children to the stack and update boundary
			else if (childIndex < treeSize && tree[cellIndex].lock == -2) {
				stack[stackPosition] = childIndex;
				stack[stackPosition + 1] = childIndex + 1;
				stack[stackPosition + 2] = childIndex + 2;
				stack[stackPosition + 3] = childIndex + 3;
			
				const uint nextLevel = level + 1;
				levelStack[stackPosition] = nextLevel;
				levelStack[stackPosition + 1] = nextLevel;
				levelStack[stackPosition + 2] = nextLevel;
				levelStack[stackPosition + 3] = nextLevel;
				stackPosition += 4;
			}

		}

		stackPosition--;
	}
	
	// Recalculate the velocity of the body from the force
	// vf=vi+a*t where a=F/bodies
	const vec2 acceleration = force / m1;
	const vec2 velocity = bodyVelocity + acceleration * deltaT;
	bodies[gid].velocity.xy = velocity;
	bodies[gid].position.xy = bodyPosition + velocity * deltaT;

}


