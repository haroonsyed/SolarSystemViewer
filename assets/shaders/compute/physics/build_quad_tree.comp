#version 430 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

const uint bodiesPerCell = 1;

struct Body {
	vec4 position;
	vec4 velocity;
	float mass;
	int id; // Should be the position in bodies[] gpu buffer
	int align2;
	int align3;
};

struct TreeCell {
	Body body;
	vec4 COM;
	int numberOfBodies;
	float mass;
	int lock;		// Is used to indicate lock and state of the cell
					// -1: Unlocked
					// -2: Not leaf node (continue traversal)
					// lock == bodyID: locked by that body
	int childCell;// Indicates position in treebuffer where child can be found
					// -1 if there is no child yet and no cell (free to insert here)
					// if there is a particle but no children (you wil need to subdivide)
					// # pointing to index of subtree
};

readonly layout(std430, binding = 4) buffer bodiesBuffer {

  Body bodies[];

};

coherent layout(std430, binding = 5) buffer treeBuffer {

  TreeCell tree[];

};

coherent layout(std430, binding = 7) buffer treeBufferSize {
  int usedTreeBufferSize;
};

uniform uint treeSize;
uniform uint bodySize;

int get_next_quadrant(vec2 boundStart, vec2 bodyPosition, float boundRange) {
  // Determine if we should insert into Q1, Q2, Q3, Q4 corresponds to cartesian quadrants
  const vec2 center = boundStart + (boundRange * 0.5);

  if(bodyPosition.x >= center.x) { // Q1 || Q4
	if(bodyPosition.y >= center.y) {
	  return 0;
	} else {
	  return 3;
	}
  } else { // Q2 || Q3
	if(bodyPosition.y >= center.y) {
	  return 1;
	} else {
	  return 2;
	}
  }
}

vec2 updated_bound_start(vec2 boundStart, float boundRange, int offset) {
   const vec2 center = boundStart + (boundRange * 0.5);

   if(offset == 0) {
	return center;
   } else if(offset == 1) {
	return vec2(boundStart.x, center.y);
   } else if(offset == 2) {
	return boundStart;
   } else {
	return vec2(center.x, boundStart.y);
   }
}

void main() {

  const uint gid = gl_GlobalInvocationID.x;
  
  if (gid >= bodySize) {
    return;
  }

  const Body body = bodies[gid];
  bool successfullyInserted = false;
 
  // Insertion state
  unsigned int treeIndex = 0;
  vec2 boundStart = vec2(-1e10, -1e10);
  float boundRange = abs(boundStart.x) * 2;

  // Check body is inbounds
  if(body.position.x < boundStart.x || body.position.y < boundStart.y || body.position.x > ( boundStart.x + boundRange) || body.position.y > (boundStart.y + boundRange)) {
	return;
  }

  while(!successfullyInserted) {

    // If this is not a leaf, travel deeper
	if(tree[treeIndex].lock == -2) {
	  
	  // Determine quadrant, and modify the bounds and treeIndex based on that
	  int quadrant_offset = get_next_quadrant(boundStart, body.position.xy, boundRange);
	  treeIndex = tree[treeIndex].childCell + quadrant_offset;
	  boundStart = updated_bound_start(boundStart, boundRange, quadrant_offset);
	  boundRange *= 0.5;
	}

    // Try to get a lock
    if(gid == atomicCompSwap(tree[treeIndex].lock, -1, gid)) {
	  memoryBarrier();

      // If no particle is here insert here
      if(tree[treeIndex].childCell == -1) {
        tree[treeIndex].body = body;
        tree[treeIndex].childCell = -2;
        
        // Ensure write are visible to other threads and free lock
        memoryBarrier();

        tree[treeIndex].lock = -1;
      }

      // Otherwise we need to move existing particle and the new particle into the subtree
	  else {
		
		// Load the relevant data from the node
		Body existingBody = tree[treeIndex].body;

		// Prevent infinite recursion if the bodies share similar position
		if(abs(body.position.x - existingBody.position.x) <= 1e-8 && abs(body.position.y - existingBody.position.y) <= 1e-8) {
		  tree[treeIndex].lock = -1;
		}
		else {
		  int offsetExisting = 0;
		  int offsetNew = 0;

		  // Travel down subtrees until we find where the offsets differ
		  while(offsetExisting == offsetNew) {
			
			// Move current position from offset in prev iteration
			treeIndex += offsetExisting;
		  
			// Determine the octant to place the particles at next subdivision
			offsetExisting = get_next_quadrant(boundStart, existingBody.position.xy, boundRange);
			offsetNew = get_next_quadrant(boundStart, body.position.xy, boundRange);
		  
			// get available spot in buffer to place particles
			int child_level_pos = atomicAdd(usedTreeBufferSize, 4);
		  
			// Lock child, then release parent as non-leaf
			tree[child_level_pos + offsetExisting].lock = int(gid);
			tree[child_level_pos + offsetNew].lock = int(gid);
			tree[treeIndex].childCell = child_level_pos;
			memoryBarrier();
			tree[treeIndex].lock = -2;
		  
		  
			// Subdivide bounds for next subdivision
			treeIndex = child_level_pos;
			boundStart = updated_bound_start(boundStart, boundRange, offsetExisting);
			boundRange *= 0.5;
		  }

		  // Write the particle values into tree buffer and unlock

		  // Existing
		  unsigned int existing_tree_pos = treeIndex + offsetExisting;
		  tree[existing_tree_pos].body = existingBody;
		  tree[existing_tree_pos].childCell = -2;

		  // New
		  unsigned int new_tree_pos = treeIndex + offsetNew;
		  tree[new_tree_pos].body = body;
		  tree[new_tree_pos].childCell = -2;

		  // Release locks
		  memoryBarrier();
		  tree[existing_tree_pos].lock = -1;
		  tree[new_tree_pos].lock = -1;
		}
	  
	  }

	  successfullyInserted = true;
    }
  }
}


