#version 430 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

const unsigned int bodiesPerCell = 5;

struct Body {
	vec4 position;
	vec4 velocity;
	float mass;
};

struct TreeCell {
	Body bodies[bodiesPerCell];
	vec4 COM;
	int lock;		// Is used to indicate lock and state of the cell
					// -1: Unlocked
					// -2: Not leaf node (continue traversal)
                    // natural number: locked
	int numberOfBodies;
	float mass;
};

coherent layout(std430, binding = 5) buffer treeBuffer {

  TreeCell tree[];

};

uniform uint levelStart;
uniform uint treeSize;
uniform uint bodySize;

void main() {

	uint gid = gl_GlobalInvocationID.x;

	uint startIndex = levelStart + (gid * 4);
	uint parent = (startIndex-1)/4;

	float totalMass = 0.0;
	vec4 COM = vec4(0.0);

	// Make sure to start moving up tree from valid leafs only
	if( tree[parent].lock != -2) {
		return;
	}

	// JUST ADD A MASS FIELD. USE RUNNING COM CALCULATION. THEN sum regardless if not leaf or leaf
	for(int i=0; i<4; i++) {
		float cellMass = tree[startIndex + i].mass;
		COM += cellMass * tree[startIndex + i].COM;
		totalMass += cellMass;
	}

	COM /= (totalMass < 1e-5 ? 1.0 : totalMass);

	// Write to parent
	tree[parent].mass = totalMass;
	tree[parent].COM = COM;

}


